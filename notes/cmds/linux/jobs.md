# https://en.wikipedia.org/wiki/Job_control_(Unix)

# list all jobs
jobs

# background current job
# Ctrl-Z: suspend current job
bg
# or, specifically
bg %1

# notice: this is the same as starting a job with & suffix



# to restore a job
fg
# or
# fg %1

# notice all job ids referenced by % prefix
# you can also refer to beginning of command name like %grep
# you can also use special conventions: 
#    %% or %+   current job
#    %-         previous job

# suspended jobs are paused and unable to continue processing
#   these are the signals used
#     SIGTSTP   terminal-issued suspend (Ctrl-z); process can catch and/or ignore
#     SIGSTOP   kernel-managed force-suspend; cannot be caught or ignored by process
#     SIGCONT   kernel-managed force-resume;  cannot be caught or ignored by process
#     SIGINT    (Ctrl-c) ask process nicely to come to a stop (to be interrupted);  
#                 can be caught and/or ignored by process
 

# background jobs continue processing without STDIN but with STDOUT+STDERR

# when the terminal session ends, all jobs are sent SIGHUP, and it waits for all to terminate before

# there is a way to tell the shell not to do this:

disown
# or
disown %1

# the command is essentially changing the parent to `init` process aka PID 1
# which will not end until the system shuts down


# it appears this works if %1 is a long-running process,
# but not if its an inline bash script ie. while true; do...done
# so i guess if the process is started it won't get stopped
# but if it stops after being disowned, the loop is not there to restart it anymore
# however you can get around this by using: bash -c 'while...'

# this is a possible alternative to
nohup


